----- 전체 구조 설계:
*app.mjs (서버 시작점)

*config.mjs (여러파일에서 공통으로 사용하는 설정값들 모음)
*router/ (URL 경로 정의)
  ㄴauth.mjs (회원가입/로그인 경로)
  ㄴposts.mjs (게시글 경로)

*middleware/ (중간 처리 단계)
  ㄴauth.mjs (토큰 검증)
  ㄴvalidator.mjs (입력값 검증)

*controller/ (실제 로직 처리)
  ㄴauth.mjs (회원 관련 처리)
  ㄴpost.mjs (게시글 관련 처리)

*Data/ (데이터 저장/조회)
  ㄴauth.mjs (회원 데이터)
  ㄴpost.mjs (게시글 데이터)

*config/ (설정 파일 관리)



----- 1. 회원가입 흐름
사용자 요청: POST /auth/signup
    ↓
① app.mjs (8번줄)
    app.use("/auth", authRouter)
    → "/auth"로 시작하는 모든 요청을 authRouter로 전달
    ↓
② router/auth.mjs (25번줄)
    router.post("/signup", validaterSignup, authController.signup)
    
    여기서 3가지 일이 순서대로 진행됨:
    
    A) validaterSignup 실행 (15~22번줄)
       - body("userid"): 아이디가 4자 이상인지, 특수문자 없는지 체크
       - body("password"): 비밀번호가 4자 이상인지 체크
       - body("name"): 이름이 비어있지 않은지 체크
       - body("email"): 이메일 형식이 맞는지 체크
       ↓
    B) middleware/validator.mjs의 validate 실행
       - 위의 검증 결과를 확인
       - 에러가 있으면 → 400 에러 반환하고 멈춤
       - 에러가 없으면 → next() 호출해서 다음 단계로 진행
       ↓
    C) controller/auth.mjs의 signup 함수 실행 (11번줄)
       ↓
③ controller/auth.mjs - signup 함수 내부
    
    13번줄: const { userid, password, name, email } = req.body
    → 사용자가 보낸 데이터를 변수에 저장
    
    16번줄: const found = await authRepository.findByUserid(userid)
    → data/auth.mjs의 findByUserid 함수 호출
    → 이미 같은 아이디가 있는지 확인
    ↓
    17~19번줄: 중복 체크
    → 이미 있으면 409 에러 반환하고 멈춤
    ↓
    21번줄: const hashed = bcrypt.hashSync(password, bcryptSaltRounts)
    → 비밀번호를 암호화 (보안을 위해)
    → "1234" → "$2b$10$xxxxxxxxxxx..." 이런 식으로 변환
    ↓
    22번줄: const user = await authRepository.createUser(...)
    → data/auth.mjs의 createUser 함수 호출
    ↓
④ data/auth.mjs - createUser 함수 (45번줄)
    
    46~53번줄: 새 user 객체 생성
    {
      id: "1638123456789", // 현재 시간으로 고유 ID 생성
      userid: "newuser",
      password: "$2b$10$xxx...", // 암호화된 비밀번호
      name: "홍길동",
      email: "test@test.com",
      url: "기본 프로필 이미지"
    }
    
    55번줄: users = [user, ...users]
    → 새 유저를 users 배열 맨 앞에 추가
    
    56번줄: return user
    → 생성된 user 객체를 controller로 반환
    ↓
⑤ 다시 controller/auth.mjs로 돌아옴 (24번줄)
    
    const token = await createJwtToken(user.id)
    → JWT 토큰 생성 (로그인 유지를 위한 인증 키)
    → user의 id를 암호화해서 토큰으로 만듦
    
    26번줄: res.status(201).json({ token, user })
    → 클라이언트에게 응답 전송
    {
      token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      user: { id: "123", userid: "newuser", name: "홍길동", ... }
    }


    ----- 2. 로그인 흐름
    사용자 요청: POST /auth/login
    ↓
① app.mjs → authRouter
    ↓
② router/auth.mjs (28번줄)
    router.post("/login", validatorLogin, authController.login)
    
    A) validatorLogin 실행 (7~16번줄)
       - 아이디/비밀번호 형식 검증
       ↓
    B) validate로 검증 결과 확인
       ↓
    C) controller/auth.mjs의 login 함수 실행
       ↓
③ controller/auth.mjs - login 함수 (29번줄)
    
    30번줄: const { userid, password } = req.body
    → 사용자가 입력한 아이디, 비밀번호 가져오기
    
    32번줄: const user = await authRepository.findByUserid(userid)
    → data/auth.mjs에서 해당 아이디를 가진 유저 찾기
    ↓
    33~35번줄: 유저가 없으면 404 에러
    ↓
    36번줄: const isValidPassword = await bcrypt.compare(password, user.password)
    → 입력한 비밀번호와 DB에 저장된 암호화된 비밀번호 비교
    → bcrypt가 자동으로 암호화해서 비교함
    → "1234"와 "$2b$10$xxx..." 비교 → true or false 반환
    ↓
    37~39번줄: 비밀번호가 틀리면 404 에러
    ↓
    40번줄: const token = await createJwtToken(user.id)
    → 로그인 성공! JWT 토큰 생성
    
    41번줄: res.status(200).json({ token, user })
    → 토큰과 유저 정보를 클라이언트에게 전송


    -----3. 포스트 작성 흐름
    사용자 요청: POST /post
Header: Authorization: Bearer eyJhbGc...
Body: { userid: "apple", name: "김사과", text: "안녕하세요" }
    ↓
① app.mjs (7번줄)
    app.use("/post", postsRouter)
    ↓
② router/posts.mjs (21번줄)
    router.post("/", validatorPost, postController.createPost)
    
    A) validatorPost 실행 (8~11번줄)
       - body("text"): 글 내용이 4자 이상인지 검증
       ↓
    B) validate로 검증 결과 확인
       - 에러 있으면 400 에러로 멈춤
       - 없으면 controller로 진행
       ↓
    C) controller/post.mjs의 createPost 함수 실행
       ↓
③ controller/post.mjs - createPost 함수 (24번줄)
    
    25번줄: const { userid, name, text } = req.body
    → 요청에서 데이터 추출
    
    26번줄: const post = await postRepository.create(userid, name, text)
    → data/post.mjs의 create 함수 호출
    ↓
④ data/post.mjs - create 함수 (61번줄)
    
    62~68번줄: 새 post 객체 생성
    {
      id: "1638123456789",
      userid: "apple",
      name: "김사과",
      text: "안녕하세요",
      createAt: "1638123456789"
    }
    
    69번줄: posts = [post, ...posts]
    → 새 게시글을 posts 배열 맨 앞에 추가
    
    70번줄: return post
    → 생성된 게시글을 controller로 반환
    ↓
⑤ 다시 controller/post.mjs로 (27번줄)
    
    res.status(201).json(post)
    → 생성된 게시글을 클라이언트에게 전송


    ----- 4. 포스트 수정 흐름
사용자 요청: PUT /post/3
Body: { text: "수정된 내용입니다" }
    ↓
① app.mjs → postsRouter
    ↓
② router/posts.mjs (24번줄)
    router.put("/:id", validatorPost, postController.updatePost)
    
    - ":id"는 URL의 숫자 부분을 변수로 받음
    - /post/3 이면 id = "3"
    
    A) validatorPost로 text 검증
    B) validate로 검증 결과 확인
    C) controller/post.mjs의 updatePost 실행
    ↓
③ controller/post.mjs - updatePost 함수 (29번줄)
    
    30번줄: const id = req.params.id
    → URL에서 id 가져오기 (여기서는 "3")
    
    31번줄: const text = req.body.text
    → 수정할 내용 가져오기
    
    32번줄: const post = await postRepository.update(id, text)
    → data/post.mjs의 update 함수 호출
    
    ⚠️ 여기 버그 발견!
    실제 코드: postRepository.update(id.text)
    올바른 코드: postRepository.update(id, text)
    ↓
④ data/post.mjs - update 함수 (73번줄)
    
    74번줄: const post = posts.find((post) => post.id === id)
    → posts 배열에서 id가 일치하는 게시글 찾기
    
    75~77번줄:
    if (post) {
      post.text = text  // 찾은 게시글의 text 수정
    }
    
    78번줄: return post
    → 수정된 게시글 반환 (없으면 undefined 반환)
    ↓
⑤ 다시 controller/post.mjs로 (33~37번줄)
    
    if (post) {
      res.status(200).json(post)  // 성공: 수정된 게시글 반환
    } else {
      res.status(404).json({ message: "게시글 없음" })  // 실패: 에러 반환
    }


    -----  5. 포스트 삭제 흐름
    사용자 요청: DELETE /post/3
    ↓
① app.mjs → postsRouter
    ↓
② router/posts.mjs (28번줄)
    router.delete("/:id", postController.deletePost)
    
    - 여기는 validator 없음 (삭제는 id만 있으면 되니까)
    ↓
③ controller/post.mjs - deletePost 함수 (40번줄)
    
    41번줄: const id = req.params.id
    → URL에서 id 가져오기
    
    42번줄: await postRepository.remove(id)
    → data/post.mjs의 remove 함수 호출
    ↓
④ data/post.mjs - remove 함수 (82번줄)
    
    83번줄: posts = posts.filter((post) => post.id !== id)
    → id가 일치하지 않는 게시글만 남김 (= 일치하는 것 삭제)
    
    예: posts = [게시글1, 게시글2, 게시글3]
        id = "2" 삭제 요청
        → posts = [게시글1, 게시글3]  (게시글2 제거됨)
    ↓
⑤ 다시 controller/post.mjs로 (43번줄)
    
    res.sendStatus(204)
    → 204 상태 코드 (성공, 응답 데이터 없음)


    ----- 6. 로그인 유지 확인 (JWT 인증) 흐름
사용자 요청: POST /auth/me
Header: Authorization: Bearer eyJhbGc...
    ↓
① app.mjs → authRouter
    ↓
② router/auth.mjs (31번줄)
    router.post("/me", isAuth, authController.me)
    
    - isAuth가 먼저 실행됨 (인증 미들웨어)
    ↓
③ middleware/auth.mjs - isAuth 함수 (7번줄)
    
    8번줄: const authHeader = req.get("Authorization")
    → 요청 헤더에서 "Authorization" 가져오기
    → 예: "Bearer eyJhbGciOiJIUzI1NiIs..."
    
    11~14번줄:
    if (!(authHeader && authHeader.startsWith("Bearer "))) {
      return res.status(401).json(AUTH_ERROR)
    }
    → "Bearer "로 시작하지 않으면 401 에러
    
    15번줄: const token = authHeader.split(" ")[1]
    → "Bearer 토큰" 을 공백으로 나눠서 토큰만 추출
    → "Bearer eyJhbGc..." → ["Bearer", "eyJhbGc..."]
    → [1]번 인덱스 = "eyJhbGc..."
    
    19번줄: jwt.verify(token, "asdfgh1234!@#$%^&*", async(error, decoded)=>{
    → JWT 토큰 검증 시작
    → 토큰을 비밀키로 해독
    
    ⚠️ 버그 발견!
    controller/auth.mjs의 비밀키: "asdfg1234!@#$"
    middleware/auth.mjs의 비밀키: "asdfgh1234!@#$%^&*"
    → 다르면 항상 에러 발생! 같아야 함
    
    20~23번줄:
    if(error){
      return res.status(401).json(AUTH_ERROR)  // 토큰이 유효하지 않음
    }
    → 토큰이 변조되었거나, 만료되었거나, 비밀키가 다르면 에러
    
    24번줄: console.log(decoded)
    → 해독된 토큰 내용 출력
    → { id: "1", iat: 1638123456, exp: 1638296256 }
    
    25번줄: const user = await authRepository.findById(decoded.id)
    → 토큰에 들어있던 id로 실제 유저 찾기
    
    26~30번줄:
    if(!user){
      return res.status(401).json(AUTH_ERROR)  // 유저가 없음
    }
    
    34번줄: req.userid = user.userid
    → 요청 객체에 userid 추가 (다음 단계에서 사용 가능)
    
    35번줄: next()
    → 인증 성공! controller/auth.mjs의 me 함수로 진행
    ↓
④ controller/auth.mjs - me 함수 (42번줄)
    
    47번줄: res.status(200).json({ message: "성공했어" })
    → 로그인 유지 확인 성공 응답


    -----각 파일(모듈)의 역할 정리( 이어서 ???????)

